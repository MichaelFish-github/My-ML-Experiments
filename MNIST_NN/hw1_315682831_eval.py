# -*- coding: utf-8 -*-
"""Untitled16.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1u-pgARaL0uJ4pP3dhsjUSzEQ1SsfZ6AP
"""

import torch
import pickle
from torchvision import datasets, transforms
import matplotlib.pyplot as plt
from scipy.stats import bernoulli
import torch.nn as nn
import numpy as np

class Neural_Network(nn.Module):
    def __init__(self, input_size,hidden_size, num_classes):
        super(Neural_Network, self).__init__()
        self.layer1 = nn.Linear(input_size, hidden_size)
        self.activation1 = nn.ReLU()
        self.layer2 = nn.Linear(hidden_size, num_classes)

    def forward(self, X):
        out = self.layer1(X)
        out = self.activation1(out)
        out = self.layer2(out)
        return out

def load_create_random_labled_test_data():
    transform = transforms.Compose([transforms.ToTensor()])
    
    test_set = datasets.MNIST('/files/',train = False,transform=transform, download=True)
    test_loader = torch.utils.data.DataLoader(dataset=test_set,batch_size= test_set.__len__(),shuffle=False)
    _,test_data = next(enumerate(test_loader))
    test_data = test_data[0]
    test_labels = torch.Tensor(bernoulli.rvs(0.5, size=test_set.__len__())).long()
    
    return test_data.view(-1, 784), test_labels

def evaluate_hw1():
  pickled_data = pickle.load(open("wet_weights_q2_315682831.pkl", 'rb'))
  my_NN = pickled_data[0]
  train_data = pickled_data[1]
  train_labels = pickled_data[2]
  test_data, test_labels = load_create_random_labled_test_data()
  criterion = nn.CrossEntropyLoss()

  if torch.cuda.is_available():
      train_data = train_data.cuda()
      train_labels = train_labels.cuda()

  # train accuracy
  train_output = my_NN(train_data)
  train_loss = criterion(train_output, train_labels)
  train_prediction = torch.max(train_output.data, 1)[1]
  train_acc = torch.sum(train_prediction == train_labels).item()
  train_acc = train_acc/train_prediction.shape[0]
  print(f"Trained model accuracy on the train set: {round(train_acc*100,2)}%")

  if torch.cuda.is_available():
    test_data = test_data.cuda()
    test_labels = test_labels.cuda()

  # test accuracy
  test_output = my_NN(test_data)
  test_loss = criterion(test_output, test_labels)
  test_prediction = torch.max(test_output.data, 1)[1]
  test_acc = torch.sum(test_prediction == test_labels).item()
  test_acc = test_acc/test_prediction.shape[0]
  print(f"Trained model accuracy on the test set: {round(test_acc*100,2)}%")

